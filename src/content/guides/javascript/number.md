---
title: 'რიცხვი'
description: 'რიცხვის ობიექტი JavasScript-ში'
keywords: 'number, nan, NaN, number methods, number properties, რიცხვი, რიცხვის მეთოდები, რიცხვის თვისებები, რიცხვის პროტოტიპის მეთოდები'
---

თითოეულ ტიპს გააჩნია თავისი ობიექტი, ამ შემთხვევაში [`Number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)-ც არ არის გამონაკლისი. `Number` წარმოადგნეს რიცხვითი ტიპის მნიშვნელობას, როგორიცა `22` ან `-22`.

## რიცხვების გადაკეთება

`Number` ფუნქციით შესაძლებელია გადავაკეთოთ სხვადასხვა ტიპები რიცხვის ტიპად. მნიშვნელობები შეიძლება გადაკეთდეს შემდეგ ნაირად:

- რიცხვები რჩება ისევ რიცხვად
- [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) გადაკეთდება, როგორც [`NaN`](#NaN).
- [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null) გადაკეთდება, როგორც `0`.
- `true` გადაკეთდება, როგორც `1`-ად ხოლო `false` როგორც `0`-ად.
- [`სტრინგები`](./doc/guides/javascript/string) გადაკეთება შედარებით კომპლექსურია, თუ არის შესაძლებელია მივიღოთ რიცხვი მაშინ გადაკეთდება, როგორც რიცხვად თუმცა თუ ფიზიკურად სტრინგის მნიშვნელბოა ვერ გადაკეთდება რიცხვად მაშინ ვღებულობთ `NaN`. მხოლოდ whitespace (`" "`) გადაკეთდება როგორც `0`.

```js
console.log(Number(undefined)); // NaN
console.log(Number(null)); // 0
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number('22')); // 22
console.log(Number('22e')); // NaN
console.log(Number('22e3')); // 22000
```

საინტერესო მომენტი არის როცა `e`-თი სწორად ჩაწერილი მნიშვნელობა გადაკეთდა, როგორც რიცხვად და არა `NaN`-ად. ამ შემთხვევაში ეს არის მოკლე გზა გამრავლების მისაღებად, როდესაც რიცხვი ძალიან დიდია ან მისი ჩაწერა გვსურს მოკლედ შეგვიძლია გამოვიყენოთ `e` სიმბოლო სწორად. თუ გვსურს, რომ რიცხვი ჩავწეროთ `200000` უფრო მოკლედ შეგვიძლია გამოვიყენოთ შემდგომი კოდი `2e5`, ანალოგიურად შეიძლება `0.002` ჩავწეროთ მოკლედ `2e-3`. თუ ცარიელი `e` სიმბოლო წერია მაშინ დარჩება, როგორც სიმბოლოდ თუმცა რიცხვთან ერთად ჩაწერის შემთხვევაში იგულისხმება `0`-ებს რაოდენობა ან დადებითად ან უარყოფითად.

## NaN

`NaN` საინტერესო მნიშვნელობა არის JavaScript-ში, მისი იდეა მდგომარეობს იმაში, რომ წარმოადგინოს ოპერაციიდან მიღებული შედეგი "არ არის რიცხვი" (**N**ot **a** **N**umber). საინტერესო ფაქტი ის არის, რომ მნიშვნელობა, რომელიც ამბობს რომ რიცხვი არ არის, ტექნიკურად რიცხვის ობიექტში არის მოთავსებული (`console.log(typeof NaN)` დააბრუნებს `'number'`).

## თვისებები

რიცხვის ობიექტს კარგი ჩაშენებული თვისებები გააჩნია სხვადასხვა სიტუაციებისთვის.

| თვისება                                                                                                                                 | აღწერა                                                                                                                      | მნიშვნელობა                     |
| --------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------- |
| [`Number.MAX_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE)                 | მაქსიმალური დადებითი რიცხვის მნიშვნელობა JavaScript-ში.                                                                     | `1.7976931348623157e+308`       |
| [`Number.MIN_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE)                 | მინიმალური უარყოფითი რიცხვის მნიშვნელობა JavaScript-ში.                                                                     | `5e-324`                        |
| [`Number.POSITIVE_INFINITY`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY) | დადებითი უსასრულობის მნიშვნელობა (რიცხვი, რომელიც მეტია `Number.MAX_VALUE`-ზე წარმოდგება, როგორც დადებითი უსასრულობა).      | `Infinity`                      |
| [`Number.NEGATIVE_INFINITY`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY) | უარყოფითი უსასრულობის მნიშვნელობა (რიცხვი, რომელიც ნაკლებია `Number.MIN_VALUE`-ზე წარმოდგება, როგორც უარყოფითი უსასრულობა). | `-Infinity`                     |
| [`Number.NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)                             | სპეციალური "არ არის რიცხვის" მნიშვნელობა.                                                                                   | `NaN`                           |
| [`Number.EPSILON`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)                     | განსხვავება `1`-სა და `1`-ზე მეტის უმცირეს მნიშვნელობას შორის.                                                              | `Number(2.220446049250313e-16)` |
| [`Number.MIN_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER)   | მინიმალური უსაფრთხო მნიშვნელობა.                                                                                            | `−9007199254740991`             |
| [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)   | მაქსიმალური უსაფრთხო მნიშვნელობა.                                                                                           | `9007199254740991`              |

უსაფრთხო მნიშვნელობები საჭიროა იმისათვის, რომ მომქდებები რიცხვებზე მოხდეს უსაფრთხოდ სიზუსტის დაკარგვის გარეშე.

```js
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 1); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true
```

რეალურად როცა `1` დავუმატეთ მაქსიმალურ უსაფრთხო მნიშვნელობას, ჩვეულებრივად დაემატა `1` მაგრამ როცა `2` დავუმატეთ მნიშვნელობა უკვე არასწორი შედეგი მივიღეთ, ამიტომაც გვაქვს მაქსიმალური უსაფრთხო მნიშვნელობა.

## მეთოდები

რიცხვებთან მუშაობის დროს დაგვჭირდება სხვადასხვა ტიპის მეთოდები სხვადასხვა ტიპის ოპერაციების დროს. უკვე ჩაშენებული მეთოდების გამოყენება გვიმარტივებს პროცესებს და გვარიდებს ახალი ბორბლის მოგონების პროცესს.

| მეთოდი                                                                                                                            | აღწერა                                                                                                                                                                                                                                                                                                                            |
| --------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`Number.parseFloat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat)       | მეთოდი პარამეტრად ღებულობს სტრინგს, გაანალიზებს ამ სტრინგს და დააბრუნებს შესაძლო მცურავი (floating ჯობია პირდაპირ ფლოატ ტერმინი დავიმახსოვროთ) რიცხვითი ტიპის მნიშვნელობას. ეს ფუნქცია იგივეა, რაც გლობალური ფუნქცია [`parseFloat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat). |
| [`Number.parseInt()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt)           | მეთოდი პარამეტრად ღებულობს სტრინგს, გაანალიზებს ამ სტრინგს და დააბრუნებს შესაძლო მთელ (integer) რიცხვითი ტიპის მნიშვნელობას. ეს ფუნქცია იგივეა, რაც გლობალური ფუნქცია [`parseInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt).                                                    |
| [`Number.isFinite()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite)           | მეთოდი ღებულობს ერთ რიცხვს და ამოწმებს რიცხვი არის თუ არა სასრული, დააბრუნებს `true` თუ სასრულია წინააღმდეგ შემთხვევაში `false`.                                                                                                                                                                                                  |
| [`Number.isInteger()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger)         | მეთოდი პარამეტრად ღებულობს ერთ რიცხვს და შეამოწმებს რიცხვი არის თუ არა მთელი რიცხვი. თუ გადაცემული მნიშვნელობა იყო მთელი რიცხვი მაშინ დააბრუნებს `true` წინააღმდეგ შემთხვევაში `fales`.                                                                                                                                           |
| [`Number.isNaN()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)                 | მეთოდი ღებულობს ერთ რიცხვს პარამეტრად და აბრუნებს გადაცემული რიცხვი არის თუ არა `NaN`. თუ რიცხვი იყო `NaN` დააბრუნებს `true` წინააღმდეგ შემთხვევაში `false`. მეთოდი იდენტრუია გლობალური [`isNaN()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN) მეთოდის.                              |
| [`Number.isSafeInteger()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger) | მეთოდი ღებულობს ერთ რიცხვს პარამეტრად და აბრუნებს `true` ან `false` მნიშვნელობას გამომდინარე იმ პირობიდან, რიცხვი არის თუ არა მოთავსებული უსაფრთხო დიაპაზონში.                                                                                                                                                                    |

## პროტოტიპის მეთოდები

როგორც გვაქვს რიცხვის ობიექტის მეთოდები, ასევე გვაქვს მისი პროტოტიპის მეთოდები. პროტოტიპის მეთოდებში იგულისხმება უშუალოდ რიცხვითი ტიპის მეთოდები და არა ობიექტის მეთოდები. განსხვავებისთვის შევხედოთ მაგალითს:

```js
let someNumber = 2;
console.log((2).toFixed(2)); // პროტოტიპის მეთოდი
console.log((2).toFixed(2)); // პროტოტიპის მეთოდი
console.log(someNumber.toFixed(2)); // პროტოტიპის მეთოდი
console.log(Number.isNaN(2)); // ობიექტის მეთოდი
```

პროტოტიპის გამოყენება რიცხვებზე შესაძლებელია 3 გზით:

- პირდაპირ რიცხვზე ორი ცალი (`.`) წერტილის გამოყენებით.
- რიცხვის ფრჩხილებში მოთავსებით.
- ცვლადში მნიშვნელობის შენახვით.

| პროტოტიპის მეთოდი                                                                                                          | აღწერა                                                                                                                                                                                                                                                                                                                  |
| -------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`toExponential()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) | მეთოდი პარამეტრად ღებულობს რიცხვს და დააბრუნებს მის ექსპონენციალურ (Exponential) შედეგს. იგივეა რაც `e` სიმბოლოს სწორად გამოყენება.                                                                                                                                                                                     |
| [`toFixed()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)             | მეთოდი ღებულობს პარამეტრად რიცხვს და დააბრუნებს მის ფიქსირებულ (fixed-point) მნიშვნელობას წერტილის შემდგომ არსებული მნიშვნელობებისთვის. `(2.1234).toFixed(2)` დააბრუნებს `2.12`                                                                                                                                         |
| [`toPrecision()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)         | მეთოდი ღებულბოს პარამეტრად რიცხვს და დააბრუნებს სიზუსტით დათვლით მნიშვნელობებს. `(123.456).toPrecision(3)` დააბრუნებს `123`.                                                                                                                                                                                            |
| [`toString()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)           | მეთოდი ღებულობს რიცხვს, რომელიც მოთავსებულია 2-36 დიაპაზონში (ნაგულისხმევი მნიშვნელობა პარამეტრის არ გადაცემის შემთხვევაში არის 10). გადაცემული რიცხვის (radix) მიხედვით დაგვიბრუნდება შესაბამისი რიცხვითი მნიშვნელობა. `(2).toString(2)` დააბრუნებს `10`, რადგან რიცხვი `2`, ორიბით ათვლის სისტმეაში შეესაბამება `10`. |

## პრაქტიკა

პრაქტიკაში თითოეული თვისების და მეთოდის გამოყენება დამოკიდებულია იმაზე თუ რისი აწყობა გვსურს. წინა თავში ავაწყეთ [`getRandomRGBColor()`](./doc/guides/javascript/math#პრაქტიკა) მეთოდი, სადაც ვაგენერირებდით შემთხვევით ფერს `rgb` სტანდარტის გამოყენებით. ეხლა შეგვიძლია `hex` სტანდარტის ფერი დავაგენერიროთ ახალი შესწავლი მეთოდით.

```js
function getHexColor() {
  return `#${Math.floor(Math.random() * 16777215).toString(16)}`;
}
```

ამ შემთხვევაში ჩვენი კოდი უფრო მოკლეა, რადგან აღარ გვიწევს სამივე ფერის დაგენერირება და შემდგომ გაერთიანება. რიცხვი `16777215` არის მაქსიმალური `rgb` მნიშვნელობა რაც შეიძლება, რომ მივიღოთ. მიღებულ რიცხვს შემდგომ გადავაკეთეთ თექვსმეტობითში, რადგან `hex` ფერი რეალურად თექვსმეტობითში წარმოდგნეილი მნიშვნელობა არის.

```js
function rgbToHex(color) {
  const rgbValues = color.match(/\d+/g);
  if (!rgbValues || rgbValues.length !== 3) {
    // არასწორი rgb ფორმატი
    return null;
  }
  const hexValues = rgbValues.map((value) => {
    const hex = Number.parseInt(value).toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  });
  return `#${hexValues.join('')}`;
}

function hexToRgb(color) {
  const hexValues = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
  if (!hexValues || hexValues.length !== 4) {
    // არასწორი hex ფორმატი
    return null;
  }
  return `rgb(${parseInt(hexValues[1], 16)},${parseInt(hexValues[2], 16)},${parseInt(hexValues[3], 16)})`;
}

console.log(rgbToHex('rgb(10,20,30)')); // "#0a141e"
console.log(hexToRgb('#0a141e')); // "rgb(10,20,30)"
```

ამჯერად შევქმენით ორი ფუნქცია `rgbToHex` და `hexToRgb`. ორივე ფუნქცია პარამეტრად ღებულობს ფერს, როგორც ტექსტური ტიპის მნიშვნელობა და აბრუნებს მის შებრუნებულ ვერსიას. `rgbToHex` ღებულობს `rgb` და აბრუნებს `hex` ხოლო `hexToRgb` შემთხვევაშ პირიქით, ღებულობს `hex` და აბრუნებს `rgb`-ს. `rgbToHex` იმპლემენტირების დროს გამოვიყენეთ `Regex` იმისათვის, რომ მასივში დაგვებრუნებინა რიცხვები, თუ `3` რიცხვზე მეტი მნიშვნელობა გვაქვს ან საერთოდ არ გვაქვს სწორი დამთხვევა მაშინ ვაბრუნებთ `null`, რადგან არასწორი `rgb` მნიშვნელობა არის წარმოდგენილი. თუ ფუნქციამ არ დააბრუნა უკვე მნიშვნელობა მაშინ ვაგრძელებთ მასივის გადაკეთებას, ვიყენებთ `map` მეთოდს, რომ მასივის თითოეული ელემენტი გადავაკეთოთ შემდგომ ლოგიკაზე, ჯერ გადავაკეთოთ თექვსმეტობით ფორმატში შემდგომ კი შევამოწმოთ, თუ გადაკეთებული მნიშვნელობის სიგრძე ტოლია `1`-ს მაშინ ჩავწერთ მას `0`-თან ერთად რადგან ორი მნიშვნელობა გვქონდეს კონკრეტულ ფერზე (`#RRGGBB`) ხოლო თუ `1`-ს ტოლი არ არის მაშინ პირდაპირ დავაბრუნოთ ეს მნიშვნელობა, საბოლოო ჯამში კი ვაბრუნებთ სტრინგს, რომელიც იწყება `#` და გვერდით ვუერთებთ მასივის მნიშვნელბოებს დაშორებების გარეშე.

`hexToRgb` ფუნქციის შემთხვევაში პრინციპი იგვეა, შემოგვაქვს `Regex`, რომ წავიკითხოთ და შევამოწმოთ `rgb` მნიშვნელობები, როგორი სიზუსტით გადმოგვეცა. მასივში უნდა მივიღოთ შემდგომი ფორმატი: `#`, პირველი, მეორე და მესამე რიცხვი. თუ არანაირი დამთხვევა არ გვაქვს ან მასივი არ შეიცავს 4 ელემენტს, მაშინ ვაბრუნებთ `null`, რადგან არასწორი `rgb` მნიშვნელობა გადმოგვეცა. თუ ფუნქციამ არ დააბრუნა უკვე მნიშვნელობა მაშინ ვაბრუნებთ `rgb` მნიშვნელობას, სადაც თითოეულ თექვსმეტობითში მოცემულ მნიშვნელობას გადავიყვანთ ისევ რიცხვით ფორმატში (ათობით ათვლის სისტემაში, რაც არის ნაგულისხმევი მნიშვნელობა რიცხვებისთვის).

## შეჯამება

ნებისმიერი რიცხვი რასაც ვწერთ JavaScript-ში საბოლოო ჯამში წარმოდგენილი არის, როგორც `Number` ობიექტში, რომელსაც გააჩნია თავისი პროტოტიპის მეთოდები. ცალკეულ `Number` ობიექტს კი გააჩნია მისი თვისებები და მეთოდები. თითოეული თვისებას და მეთოდს გააჩნია საკუთარი გამოყენების სიტუაცია, რომელიც სამომავლოდ საკმაოდ დაგეხმაროთ.

იხილეთ სამაგალითო კოდები [playground](./playground/simple/guides/javascript-number)-ში.
