---
title: 'ფუნქცია'
description: 'სამომხმარებლო ფუნქციები JavaScript-ში'
keywords: 'functions, return, default params, void functions, scope, hoisting, hoisted, რეკურსია, recursion, arrow, async, await'
---

ფუნქციები არის ფუნდამენტალური ნაწილი JavaScript-ში. ფუნქციის იდეა მდგომარეობს, რომ შევქმნათ მრავალჯერადად გამოყენებადი კოდის ფრაგმენტი, რომელსაც გამოვიძახებთ სურვილისამებრ ნებისმიერ დროს. ფუნქციას შესაძლოა გადავცეთ სხვადასხვა ტიპის პარამეტრები, რის მიხედვითაც შესაძლოა შევინარჩოთ დინამიურობის პროცესი. დინამიურობის პროცესში იგულისხმება, გადაცემული პარამეტრიდან შესრულებული/დაბრუნებული მოქმედებები.

## ფუნქციის ტიპები

ფუნქციები შესაძლოა დავყოთ ორ ტიპად:

- ფუნქცია, რომელიც მნიშვნელობას აბრუნებს (`return` ტიპის ფუნქციები).
- ფუნქცია, რომელიც მნიშვნელობას არ აბრუნებს (`void` ტიპის ფუნქციები).

ყოველთვის არ არის სავალდებულო, რომ ფუნქციამ მნიშვნელობა დააბრუნოს, ამიტომაც გვაქვს ვოიდის ტიპის ფუნქციები. მათი დანიშნულება მდგომარეობს, რომ სხვადასხვა ტიპის მნიშვნელობები გაუშვას, მაგალითად: დაიწყოს თამაშის მთავარი ფუნქცია, განახლება გაუკეთოს ვიზუალს და ა.შ.

ფუნქცია, რომელსაც არ უწერია `return` ავტომატურად იგულისხმება, რომ ეს ფუნქცია არის ვოიდის ტიპის, თუ შევეცდებით მისგან მნიშვნელობის წაკითხვას დაბრუნებული შედეგი ყოველთვის იქნება [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).

## ფუნქციის აღწერა

ფუნქციის აღსაწერად გამოიყენება `function` ქივორდი (keyword), რომლის შემდგომაც კეთდება შემდომგი ჩანაწერი:

- ფუნქციის სახელი ([Camel case-ს სტილს](./doc/guides/javascript/variable#ცვლადის_სახელის_სტილი))
- პარამეტრების სია, რომელიც ჩაწერილი იქნება `()` ფრჩხილებში, თითოეული პარამეტრის განსაცალკევებლად გამოიყენება `,` (მძიმე).
- კოდის ფრაგმენტი, რომელიც მოქცეული იქნება `{}` (ფიგურულ) ფრჩხილებში.

მაგალითსთვის აღვწეროთ მარტივი ფუნქცია, რომელიც ღებულობს რიცხვს და დავაბრუნოთ მისი კვადრატის მნიშვნელობა:

```js
function square(number) {
  return number * number;
}
```

ამ შემთხვევაში ფუნქცია `square` ღებულობს ერთ პარამეტრს, სახელად `number`-ს. როცა გამოვიძახებთ ფუნქცია `square` აუცილებელი არის, რომ გადავცეთ `number` მნიშვნელობა პარამეტრის სახით, არ გადაცემის შემთხვევაში მიენიჭება მას `undefined` მნიშვნელობა, რაც არასწორ შედეგს დაგვიბრუნებს. გადმოცემულ მნიშვნელობას ვამბრავლებთ საკუთარ თავზე და მნიშვნელობას ვაბრუნებთ `return` ქივორდით.

მაგალითისთვის გავტესტოთ ჩვენს მიერ დაწერილი ფუნქცია:

```js
function square(number) {
  return number * number;
}

console.log(square(2)); // 4
console.log(square(4)); // 16
console.log(square(8)); // 64
console.log(square()); // NaN
```

## ფუნქციის პარამეტრები

ფუნქციას შესაძლოა იმდენი პარამეტრი გადავცეთ რამდენიც გვსურს. თითოეული პარამეტრი ერთმანეთისაგან უნდა იყოს გამოყოფილი `,` (მძიმით). თითოეული პარამეტრი შესაძლოა მივანიჭოთ ნაგულისხმევი (default) მნიშვნელობა. ნაგულისხმევი პარამეტრები უმჯობესია ეწეროს ჩვეულებრივ პარამეტრამდე. ნაგულისხმევი, რომ გახდეს პარამეტრი უბრალოდ უნდა მივანიჭოთ ფუნქციას მნიშვნელობა.

მაგალითი:

```js
function logName(name = 'educata') {
  console.log(`სასწავლებლის სახელია: ${name}`);
}

logName(); // 'სასწავლებლის სახელია: educata'
logName('EverREST'); // 'სასწავლებლის სახელია: EverREST'
```

კონკრეტულ შემთხვევაში აღვწერეთ ფუნქცია `logName`, რომელსაც პარამეტრის არ გადაცემის შემთხვევაში მისი მნიშვნელობა გახდება `educata`, რადგან ეს იყო `name` პარამეტრის ნაგულისხმევი მნიშვნელობა, მაგრამ როცა მნიშვნელობა გადავეცით, მიიღო ის მნიშვნელობა, რაც პარამეტრის სახით მიიღო. ნაგულისხმევ პარამეტრს, ყოველთვის გადააწერს მნიშვნელობას გადაცემული მნიშვნელობა, რეალურად მეორე გამოძახების დროს ამიტომ მოგვცა განსხვავებული შედეგი.

მაგალითი:

```js
function sum(a, b = 22) {
  return a + b;
}

console.log(sum()); // NaN
console.log(sum(1)); // 23
console.log(sum(2, 2)); // 4
```

## ფუნქციის ექსპრეშენები

ფუნქციის აღწერა არამხოლოდ იმ გზით არის შესაძლებელი, რაც მანამდე განვიხილეთ, არამედ შესაძლოა შეიქმნას ასევე ფუნქციის ექსფრეშენებით (გამოსახულებები).
ფუნქცია შესაძლოა იყოს [ანონიმური](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions), როცა მას არ გააჩნია სახელი. მაგალითისთვის შესაძლოა ჩვენი ფუნქცია აგვეღწერა შემდგომ ნაირად:

```js
const square = function (number) {
  return number * number;
};
```

მსგავს ტიპად აღწერილი ფუნქცია არის ანონიმური და მისი გამოძახება შესაძლებელია ცვლადის სახელის გამოყენებით. თუმცა მსგავსად აღწერილი ფუნქცია არ გადის [`hoisting`](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)-ს პროცესს ამიტომაც ხშირ შემთხვევაში უმჯობესია `function` ქივორდის გამოყენება. მარტივად, რომ ავხსნათ ჰოისტინგი გულისხმობს ცვლადების/ფუნქციების წვდომას კონკრეტულ ადგილას, პირობითად შესაძლებელია ფუნქცია აღვწეროთ ქვემოთ და გამოვიძახოთ ზემოთ (ჰოისტინგზე დეტალური ინფორმაციისთვის იხილეთ [`hoisting`](./doc/guides/javascript/hoisting)). მაგალითად:

```js
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization

const square = function (number) {
  return number * number;
};
```

```js
const square = function (number) {
  return number * number;
};
console.log(square(5)); // 25
```

```js
console.log(square(16)); // 256

function square(number) {
  return number * number;
}

console.log(square(32)); // 1024
```

პირველი მაგალითის შემთხვევაში წარმოიქმნა აქსსეს ერორი, რაც მოისაზრებს ცვლადის გამოყენებას მის ინიციალიზებამდე. მესამე მაგალითში იგივე პრობლემას არ ვაწყდებით, რადგან ფუნქცია გადის ჰოისტინგს, რაც შესაძლებლობას გვაძლევს, რომ გამოყენებადი იყოს მთლიან [scope](./doc/guides/javascript/scope)-ში (ან მთლიან აპლიკაციაში, თუ აღწერილი ფუნქცია, არის მთავარ JavaScript ფაილში).

პ.ს არ არის სავალდებულო კვადრატისთვის, ფუნქციის შემოღება, რადგან გვაქვს ბევრი მიდგომა, რომ კვადრატი მივიღოთ JavaScript-ში:

- [`**`](./doc/guides/javascript/operations-operators#არითმეტიკული_ოპერაციები) ხარისხის ოპერატორის სახით
- [`Math.pow`](./doc/guides/javascript/math#მეთოდები) მეთოდის გამოყენებით

## რეკურსია

რეკურსია არის მოვლენა , როდესაც რომელიმე ფუნქციაში ხდება იგივე ფუნქციის გამოძახება. ზოგიერთ ამოცანის ამოხსნის პროცესი შეიძლება წარმოვადგინოთ , ისეთი ტიპის პრინციპით სადაც ფუნქცია იძახებს საკუთარ თავს და შევასრულოთ რეკურსიულად.

```js
// გრძელი if/else ჩაწერით
function pow(x, n) {
  if (n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
// ტერნარული ოპერატორის ჩანაწერით
function powTernary(x, n) {
  return n === 1 ? x : x * powTernary(x, n - 1);
}
// შედეგი ორივე ფუნქციისთვის ერთი და იგივე არის მაგრამ ტერნარული ოპერატორით ჩანაწერი უფრო მოკლე არის და არ მოითხოვს ზედმეტი if/else ჩანაწერის ბლოკებს
console.log(pow(2, 10)); // 1024
console.log(powTernary(2, 10)); // 1024
```

განვიხილოთ მაგალითი თითოეული რეკურსიული იტერაციისთვის.

- `pow(2, 10) = 2 * pow(2, 9)`
- `pow(2, 9) = 2 * pow(2, 8)`
- `pow(2, 8) = 2 * pow(2, 7)`
- `pow(2, 7) = 2 * pow(2, 6)`
- `pow(2, 6) = 2 * pow(2, 5)`
- `pow(2, 5) = 2 * pow(2, 4)`
- `pow(2, 4) = 2 * pow(2, 3)`
- `pow(2, 3) = 2 * pow(2, 2)`
- `pow(2, 2) = 2 * pow(2, 1)`
- `pow(2, 1) = 2`
- საბოლოო ჯამში მიიღება: `2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2`

pow ფუნქცია რეკურსიულად იძახებს თავის თავს მანამ სანამ `n` არ გაუტოლდება 1.

განსხვავებული მაგალითი რეკურსიულად [ფაილების წაკითხვა](./playground/simple/guides/javascript-tree-recursion)-ზე:

უშუალოდ [iswavle.com](https://iswavle.com)-ს აწყობისას, კონტენტის დასარენდერებლად რეკურსია არის გამოყენებული, იხილეთ [კოდი](https://github.com/educata/iswavle/blob/main/prerender/render-content.ts).

## Arrow ფუნქცია

`arrow` ფუნქცია არის ალტერნატივა ჩვეულებრივი [ფუნქციის](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions), მცირედი მოდიფიცირებებით. მისი სინტაქსი შემოკლდა და შეიცვალა მცირედადა გამოყენებების სტანდარტები:

- `arrow` ფუნქციას არ გააჩნია თავიანთი: [`this`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) (განხილული არის შემდგომ თავშიც), [`arguments`](https://developer.mozilla.org/en-US/docs/Glossary/Argument), [`super`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) და არ შეიძლება მათი გამოყენება, როგორც [მეთოდების](./doc/guides/javascript/object-basics#ობიეტქის_მეთოდები) სახით.
- `arrow` ფუნქციას ვერ გამოვიყენებთ, როგორც [`constructor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor). მათი გამოძახება [`new`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) თანხლებით გამოიტანს [`TypeError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError)-ს.
- `arrow` ფუნქცია არ შეიძლება იყოს გამოყენებული [`yield`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield) შიგნით და არ შეიძლება მათი გამოყენება, როგორც გენერატორი ფუნქცია.

მისი სინტაქსი სახელს ამართლებს. მისი სინტაქსი:

```js
() => ფუნქციის შედეგი

param => ფუნქციის შედეგი

(param) => ფუნქციის შედეგი

(param1, paramN) => ფუნქციის შედეგი

() => {
  ფუნქციის კოდი
}

param => {
  ფუნქციის კოდი
}

(param1, paramN) => {
  ფუნქციის კოდი
}
```

სინტაქსის მაგალითი:

```js
const printHere = () => {
  console.log('Here');
};

printHere(); // დაილოგება "Here"
// შემდგომ სტატიებში იქნება უფრო მეტი მაგალითი განხილული
```

## ასინქრონული ფუნქციები

ასინქრონული ტიპის ფუნქციები საშუალების გვაძლევს [`promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)-ებს მოვუსმინოთ [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) ქივორდის საშუალებით, შედეგად კი ვღებულობთ უფრო სუფთა კოდს (თავს ვარიდებთ პრომისების გრძელ კოდს).

ასინქრონული პროგრამირების იდეა განხილული იქნება [`promise & async`](./doc/guides/javascript/promise&async) თავში.
