---
title: 'ცვლადი'
description: 'let vs var vs const'
keywords: 'js, javascript, ჯავასკრიპტი, var, let, const, global-scope, cvladis saxeli, ცვლადის სახელი, ცვლადის სახელის სტილი, ცვლადი, ცვლადები'
---

ცვლადი გვჭირდება გარკვეული ტიპის ინფორმაციის შესანახად, რომელსაც შემდეგ სხვაგან გამოვიყენებთ ან შევუცვლით მნიშვნელობას.
არსებობს ისეთი გამოცხადების, ანუ დეკლარაციის ტიპები, რომლებიც გვაძლევს საშუალებას, მინიჭებულ ცვლადს შევუცვალოთ მნიშვნელობა
და ასევე გვაქვს ისეთი დეკლარაციის ტიპი, რომელიც ამის უფლებას არ გვაძლევს.

ცვლადების დეკლარაცია შეგვიძლია შემდეგი ქივორდებით: `var`, `let`, `const`.

## var

`var`-ით დეკლარაციის შემთხვევაში შესაძლოა აღიწეროს ცვლადი, რომელიც განსაზღვრული იქნება ფუნქციაში,
ან გლობალურად ([global-scope](https://developer.mozilla.org/en-US/docs/Glossary/Global_scope)),
ცვლადის მნიშვნელობის შეცვლა შესაძლებელია ნებისმიერ დროს.
ასე ტიპად გამოცხადებული ცვლადი გადის [hoisting-ს](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting).

## let

`let`-ით დეკლარაციის შემთხვევაში, შესაძლოა აღიწეროს ცვლადი, რომელიც განსაზღვრული ინქება ფუნქციაში,
ან ლოკალურ ბლოკში ([block-scope](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)),
ცვლადის მნიშვნელობის შეცვლა შესაძლებელია ნებისმიერ დროს. ასე გამოცხადებული ცვლადი არ გადის hoisting-ს.

## const

`const`-ით დეკლარაცია ჰგავს `let`-ს, `const`-იც ლოკალურ ბლოკში არის მოთავსებული, თუმცა არის ერთი განსხვავება:
მისი აღწერის შემდეგ შეუძლებელია მისი გადაკეთება (გამონაკლისი შემთხვევა არსებობს მასივთან და ობიექტთან მიმართებაში,
შესაძლებელია, რომ განვანახლოთ ელემენტები ან უბრალოდ ამოვიღოთ ელემენტები, მაგრამ ცვლადი ისევ დარჩება მასივად ან ობიექტად).

## ინიციალიზება

ცვლადის ინიციალიზაცია გულიხსმობს:

- ცვლადის გამოცხადების
- ცვლადისთვის პირველადი მნიშვნელობის მინიჭებას

ცვლადის აღსაწერად საჭიროა:

```
დეკლარაციის_ტიპი ცვლადის_სახელი = მნიშვნელობა;
```

მაგალითები:

```js
var projectName = 'EverREST'; // Camelcase
let organization_name = 'Educata'; // Snakecase
const DocumentationProject = 'Iswavle'; // Pascalcase
```

## ცვლადის სახელი

ცვლადის სახელი უნდა ასახავდეს ცვლადის მნიშვნელობას. პრაქტიკაში უმჯობესია ინგლისური ცვლადის სახელები.
სახელი უნდა შედგებოდეს, რამოდენიმე სიმბოლოსაგან,
თუ დეკლარაციას ვაკეთებთ [ლუპიში](./doc/guides/javascript/loops), მაშინ მისაღებია i, j და ა.შ.
[მასივი](./doc/guides/javascript/array)-ის სახელი უმჯობესია ჩაიწეროს მრავლობითში, მაგალითად: `students` და არა `student`.

## ცვლადის სახელის სტილი

ცვლადის სახელის აღწერის დროს შესაძლებელია სხვადასხვა სტილის გამოყენება. ხშირად გამოყენებადი სტილები:

- Camel case
  - პირველი სიმბოლო პატარა ასოთი, მის შემდეგ არსებული ყველა სიტყვა იწყება დიდი ასოთი.
  - კარგია მარტივი ტიპის ცვლადებისათვის
  - მაგალითი: `userName`
- Camel case with prefixes
  - იგივე Camel case, უბრალოდ პრეფიქსი აქვს, ცვლადის ტიპიდან გამომდინარე, თუ არის ბულიანი მაშინ იწყება `is` თუ რაიმე მნიშვნელობას აბრუნებს ფუნქცია სახელი იწყება `get` და მსგავსად.
  - კარგია [ფუნქციის](/doc/guides/javascript/function) სახელებისათვის
  - მაგალითი: `isUserAuthed` | `getRandomNumber`
- Snake case
  - ყოველი სიტყვა არის პატარა ასოებით დაწერილი, სიტყვებს შორის დაშორებისთვის კი გამოიყენება `_`.
  - კარგია მარტივი ტიპის ცვლადებისათვის
  - მაგალითი: `user_name`
- Upper snake case
  - ყოველი სიტყვა არის დიდი ასოთი, სიტყვებს შორის დაშორებისთვის კი გამოიყენება `_`.
  - კარგია მუდმივი(const) ცვლადის მნიშვნელობებისთვის, რომელიც არ იცვლება.
  - მაგალითი: `MIN_VALUE`
- Pascal case
  - ყოველი სიტყვა იწყება დიდი ასოთი.
  - კარგია [კლასი](/doc/guides/javascript/oop)-ს, [ინტერფეისი](./doc/guides/typescript/types#Interface)-ს და [ენამის](./doc/guides/typescript/types#Enums) სახელებისათვის.
  - მაგალითი: `UserName`
- Kebab case
  - ყოველი სიტყვა არის პატარა ასოებით დაწერილი, სიტყვებს შორის დაშორებისთვის კი გამოიყენება `-`.
  - კარგია URL-ს სახელისათვის და CSS კლასის სახელისათვის.
  - მაგალითი: `path/display-posts` | `profile-avatar`
- Hungarian Notation
  - ცვლადის სახელი იწყება ცვლადის ტიპით, შემდეგ კი გრძელდება, როგორც Camel case.
  - ადრე გამოიყენებოდა ძველ პროგრამულ ენებში, რადგან არ იყო მრავალფეროვნება ტიპებში თუმცა დღეისათვის იშვიათად.
  - მაგალითი: `strName` | `intCount`

## ცვლადის გამოყენება

ერთხელ დეკლარირებული ცვადი შეგვიძლია ბევრგან გამოვიყენოთ:

```js
const PI = 3.14;
let radius = 5;

let circleArea = PI * radius ** 2;

console.log(circleArea); // 78.5
```

:::INFO
`console.log()` არის ბრაუზერში ჩაშენებული ფუნქცია, რომელსაც შეგვიძლია მივაწოდოთ ნებისმიერი მნიშვნელობა ან ცვლადი
და მას ბრაუზერი [კონსოლში](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Tools_and_setup/What_are_browser_developer_tools#the_javascript_console) გამოიტანს.
დეველოპერები მას ხშირად ვიყენებთ ფუნქციონალის გასატესტად ან ხარვეზების გამოსასწორებლად.
:::

`let`-ით დეკლარირებულ ცვლადებს შეგვიძლია შევუცვალოთ მნიშვნელობა:

```js
let name = "George";

console.log(name); // George

name = "Adam";

conosle.log(name); // Adam

let place = "Tbilisi";
// place-ის ახალი მნიშვნელობა არის წინა მნიშვნელობა, სადაც Tbi ჩანაცვლებულია Mang-ით
place = place.replace("Tbi", "Mang");
console.log(place); // Manglisi
```

`let`-ით დეკლარირებულ ცვლადებს ასევე შეგვიძლია თავდაპირველად მნიშვნელობა არ მივაწოდოთ და მხოლოდ გამოვაცხადოთ:

```js
let happinessReasons;
console.log(happinessReasons); // undefined

happinessReasons = "cat";
console.log(happinessReasons); // cat

```

ასეთ შემთხვევაში ცვლადის მნიშვნელობა იქნება `undefined`, ანუ **განუსაზღვრელი**.

`const`-ითა და `let`-ით დეკლარირებული ცვლადები აუცილებელია, რომ იქამდე არსებობდნენ, სანამ მათ გამოვიყენებთ.
მაგალითად, ასეთი კოდი გამოიწვევს ერორს:

```js
console.log(city);

const city = "Tbilisi";
```

ბრაუზერის კონსოლი ამოგვიგდებს შეცდომას, რომ ცვლადის მნიშვნელობას ინიციალიზაციამდე ვერ ჩავწვდებით.

`var` ის შემთხვევაში საქმე სხვანაირად გვაქვს:

```js
console.log(city);

var city = "Tbilisi";
```

კონსოლში გამოვა მნიშვნელობა `undfined`. რა ხდება?
ამისთვის უნდა გავიაზროთ ორი მნიშვნელოვანი პრინციპი: ცვლადის ფარგლები (scope) და hoisting.

## ცვლადის ფარგლები (scope)

ცვლადი შეიძლება ეკუთვნოდეს სამიდან ერთ ფარგლებს:

- **გლობალური ფარგლები:** სკრიპტის რეჟიმში გაშვებიული კოდი ავტომატურად ამ ფარგლებში მუშაობს.
- **მოდულის ფარგლები:** კოდის ფარგლები, რომელიც მოდულის რეჟიმში მუშაობს.
- **ფუნქციის ფარგლები:** ფარგლები, რომელიც ფუნქციით იქმნება.

გარდა ამისა, `let`-ითა და `const`-ით დეკლარირებული ცვლადები შეიძლება ეკუთვნოდნენ **ბლუკურ ფარგლებს**.
ეს არის ფარგლები, რომელიც კოდში იქმნება ფიგურული ფრჩხილებით (რაც ქმნის [ბლოკს](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)).

როცა ცვლადს დეკლარაციას ვუკეთებთ ნებისმიერი ფუნქციისა თუ ვლოკის გარეთ, იგი ხდება _გლობალური ცვლადი_,
რადგან იგი ხელმისაწვდომია დოკუმენტის ნებისმიერ სხვა კოდში.
როცა ცვლადს დეკლარაციას ვუკეთებთ ფუნქციაში, იგი ხდება _ლოკალური ცვლადი_,
რადგან იგი მხოლოდ ამ ფუნქციის შიგნით არის ხელმისაწვდომი.

:::INFO
ფუნქციისა და კონტროლის ბლოკებს დეტალურად შემდეგ სტატიებში გაეცნობით.
:::

მაგალითად, `let` ან `const` დეკლარაცია მოცემულ მაგალითში შეკრულია `if` ბლოკში,
რომელიც ამოწმებს, შემთხვევით დაგენერირებული რიცხვი (`Math.random()`), არის თუ არა მეტი 0.5-ზე (`> 0.5`).
ეს ცვლადი ამ ბლოკის (ფიგურული ფრჩხილების) გარეთ არ არსებობს.

```js
if (Math.random() > 0.5) {
  const num = 5;
}
console.log(num); // ReferenceError: num is not defined
```

მიუხედავად ამისა, `var`-ით დეკლარირებული ცვლადები არ არის ბლოკური გარგლების,
თუმცა ისინი ლოკალურია იმ ფუნქციებში (ან გლობალურ ფარგლებში), სადაც ბლოკია შექმნილი.

მაგალითად, წინამდებარე კოდი კონსოლში წარმატებით დალოგავს 5-ს, რადგან `n` ცვლადი არსებობს გლობალურ კონტექსტში,
იგი არ არის შეზღუდული `if` ბლოკის ფარგლებში:

```js
if (true) {
  var n = 5;
}
console.log(n); // 5
```

## Hoisting

ჰოისთინგი ჰულისხმობს პროცესს, როცა ჯოდის ინტერპრეტატორს, კოდის განხორციელებამდე, გადააქვს ცვლადის, კლასისა თუ ფუნქციის დეკლარაცია
მათი სქოუფის თავში. 
`var` ით დეკლარირებული ცვლადები გადიან hoisting-ს.
Hoist ნიშნავს ამწეს, ამიტომ შეგვიძლია წარმოვიდგინოთ, თითქოს `var`-ით შექმნილი ცვლადები გაშვებამდე
"აწეულები არიან" ფუნქსიის ან გლობალური ფარგლების თავში.
მიუხედავად ამისა, თუ ჩვენ შევეცდებით, წავიკითხოთ ცვლადის მნიშვნელობა ინიციალიზაციამდე,
ჩვენ ნებისმიერ შემთხვევაში მივიღებთ `undefined`-ს, რადგან hoisting ხდება მხოლოდ ცვლადის _დეკლარაციაზე და ნაგულსხმებ ინიციალიზაციაზე_,
თუმცა არა მნიშვნელობის მინიჭებაზე.

```js
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "ლოკალური ცვლადი";
})();
```

ზემოთ არსებული მაგალითი იქნება ინტერპრეტირებული, როგორც:

```js
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "ლოკალური ცვლადი";
})();
```

`var`-ით დეკლარირებულ ცვლადებს, იდეალურ ვარიანტში უნდა მოვერიდოთ,
რადგან ასეთი თვისებების გამო იგი მიდრეკილია ხარვეზებისკენ.
თუ გამოსავალი არ გვაქვს (მაგალითად ძველ პროექტზე ან ძველი ბრაუზერებისთვის ვმუშაობთ),
ჯობია რომ ცვლადები გამოვაცხადოთ ფუნქციის (ან ფაილის) თავში.

`let`-ითა და `const`-ით დეკლარირებულ ცვლადებს ახასიათებთ ე.წ [დროებითი მკვდარი ზოონა](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz),
რომელიც იქმნება ცვლადის დეკლარაციამდე, ზედა სტრიქონებში. ეს არის ადგილი, სადაც ცვლადი მიუწვდომელია.
დეკლარაციამდე ცვლადის გამოყენება გამოწვევს [`ReferenceError`-ს](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError).

```js
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

`var`-ისგან განსხვავებით, ასეთი ცვლადების hoisting ხდება _მხოლოდ დეკლარაციაზე_.
შესაბამისად, კონსოლში ვიღებთ შენიშვნას, რომ არ შეგვიძლია მოცემული ცვლადის წაკითხვა, რადგან იგი ჯერ დეკლარირებული არ არის.
ეს შენიშვნა არის გამიზნულად შექმნილი, რათა ჩვენ პროგრამირებაში სწორი სტანდარტები დავიცვათ.

## შეჯამება

ამ თავში ვისწავლეთ ჯავასკრიპტის ცვლადები, მათი გამოცხადების ტიპები და მათთან დაკავშირებული ცნებები,
როგორიცაა hoisting და scope.
