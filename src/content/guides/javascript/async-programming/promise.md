---
title: 'Promise'
description: 'Promise-ს გამოყენება JavaScript-ში'
keywords: 'სინქრონული, ასინქრონული, promise, callback'
---

ასინქრონული კოდის დასაწერად, ხშირ შემთხვევაში საჭიროა გამოვიყენოთ [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)-ები.

## რა არის Promise ?

`Promise` ეს არის ობიექტი, რომელიც მარტივი სახით შეგვიძლია წარმოვიდგინოთ, როგორც დაპირება. ყოველ დაპირებას გააჩნია 3 ეტაპი:

- _pending_: დასაწყისი _state_, როცა დაპირება მუშავდება (არც შესრულდა მაგრამ არც უარყო).
- _fulfilled_: წარმატებულად შესრულებული დაპირება.
- _rejected_: წარუმატებლად შესრულებული დაპირება.

## როგორ მუშაობს Promise ?

პრომისის შესაქმნელად საჭიროა გამოვიყენოთ `Promise` ობიექტის კონსტრუქტორი, რომელსაც პარამეტრად მივაწვდით ორ `callback` ფუქნციას:

- `resolve`: წარმატებულად შესრულების შემთხვევაში დამბრუნებელი ფუნქცია.
- `reject`: წარუმატებლად შესრულების შემთხვევაში დაბრუნებული ფუნქცია.

```js
const promiseForNumber = new Promise((resolve, reject) => {
  const random = Math.floor(Math.random() * 2);
  if (random === 1) {
    resolve('გაგიმართლათ, დაგენერირდა 1');
  } else {
    reject('არ გაგიმართლათ, დაგენერირდა 0');
  }
});
```

ასე შევქმენით `Promise`, რომელზეც მოსმენის შემთხვევაში გაეშვება შემთხვევითი რიცხვის დაგენერირების ლოგიკა, რომელიც დააგენერირებს რიცხვს ნულიდან ერთის ინტერვალში. თუ დაგენერირებული მნიშვნელობა ერთის ტოლია მაშინ ვაბრუნებთ წარმატებულად შესრულების მნიშვნელობას, რომელიც ამ შემთხვევაში არის: `'გაგიმართლათ, დაგენერირდა 1'`, ხოლო წარუმატებლად გაშვების შემთხვევაში ვაბრუნებთ: `'არ გაგიმართლათ, დაგენერირდა 0'`.

ერთის მხრივ მარტივი შედარებისთვის `Promise` შეგიძლიათ წარმოიდგინოთ, როგორც ფუნქცია. ფუნქცია რომელსაც აქვს ორი `return`, ერთი კარგი შემთხვევისთვის ხოლო მეორე ცუდი შემთხვევისთვის.

`Promise` გამოყენებისთვის საჭიროა გამოვიყენოთ შემდგომი სინტაქსი:

```js
const promiseForNumber = new Promise((resolve, reject) => {
  const random = Math.floor(Math.random() * 2);
  if (random === 1) {
    resolve('გაგიმართლათ, დაგენერირდა 1');
  } else {
    reject('არ გაგიმართლათ, დაგენერირდა 0');
  }
});

promiseForNumber
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.log(error);
  });
```

ასე მივიღეთ დაპირება, რომელზეც მოსმენის შემთხვევაში მივიღებთ ან კარგ შედეგს ან ცუდს.

## სად გამოვიყენოთ Promise ?

`Promise` შეგიძლიათ გამოიყენოთ ნებისმიერ ადგილას სადაც საჭიროა ასინქრონული მომქედებები. მაგალითისთვის განვიხილოთ შემდგომი კოდი:

```js
function randomNumber(max = 100) {
  setTimeout(() => {
    return Math.floor(Math.random() * max);
  }, 2000);
}
```

შევქმენით ისეთი `randomNumber` ფუნქცია, რომელსაც პირობითად 2 წამი სჭირდება შემთხვევითი რიცხვის შესაქმნელად. თუმცა როცა გავწერეთ `return` ეს არ იყო `randomNumber`-ს მიერ დაბრუნებული მნიშვნელობა, არამედ ეს არის `setTimeout`-სთვის დაბრუნებული მნიშვნელობა.

თუ შევეცდებით ამ ფუნქციის გამოყენებას მისი მნიშვნელობა იქნება `undefined`, რადგან `randomNumber` ფუნქციაში არ გვაქვს `return`. რეალურად კი გვიწერია ფუნქციის შიგნით `return`, მაგრამ აქვე შიგნით მეორე ფუნქციაც გვიწერია, რაც მეორე ფუნქციისთვის ეშვება და არა `randomNumber`-სთვის.

თუ გვსურს `randomNumber`-ის ფუქნციამ, რომ მნიშვნელობა დააბრუნოს 2 წამის შემდგომ, საჭიროა მისი არა როგორც სინქრონულად ჩაწერა, არამედ როგორც ასინქრონულად.

გადავწეროთ კოდი შემდგომ ნაირად:

```js
function randomNumber(max = 100) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(Math.floor(Math.random() * max));
    }, 2000);
  });
}
```

`randomNumber` ფუნქცია აბრუნებს პრომისის მნიშვნელობას, რომელიც შესრულდება 2 წამის შემდგომ. მისი გამოყენება კი შეგვიძლია მარტივად:

```js
randomNumber().then((result) => {
  console.log(`შემთხვევითი რიცხვია: ${result}`);
});
```

ამ კონკრეტულ მაგალითში `reject` დაწერა არ იყო საჭირო, ამიტომაც `catch` დაწერაც არ არის საჭირო.

მსგავსად ნებისმიერ ადგილას, სადაც საჭიროა ასინქრონული კოდის დაწერა, შეგიძლიათ გამოიყენოთ `Promise`-ები.

## განსაზღვრული Promise

ზოგჯერ შესაძლოა დაგჭირდეთ ისეთი კოდის დაწერა, რომელიც დააბრუნებს პირდაპირ წარმატებულად შესრულებულ პრომის ან წარუმატებლად შესრულებულს.

მაგალითისთვის განვიხილოთ შემდგომი მაგალითი:

```js
const cache = {
  users: [
    {
      id: 1,
      name: 'john',
      email: 'john@doe',
    },
  ],
};

function fetchSomeUser(id) {
  const user = cache.users.find((user) => user.id === id);
  if (user) {
    return Promise.resolve(user);
  }
  return new Promise((resolve, reject) => {
    // სიმულაცია მომხარებლის მოთხოვნის
  });
}
```

ამ შემთხვევაში გვაქვს პირობითად შექმნილი `cache`, სადაც შენახულია ერთია მომხარებელი, ასევე გვაქვს ფუნქცია, რომელიც `id` მიხედვით გვიბრუნებს მომხარებელს. `fetchSomeUser`-ს ფუნქცია ამომწებს ჯერ ხომ არ არის `cache`-ში, რომელიმე მომხარებელი შენახული იგივე `id`-ით. თუ მოიძებნა მაშინ აბრუნებს მის მნიშვნელობას `Promise`-ში შეფუთული, რადგან დარჩენილი კოდის ნაწილიც `Promise`-ს აბრუნებს, ამრიგად კოდის შეცვლა აღარ მოგვიწევს პირველი `if`-ს გამო.

[`Promise.resovle`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) გამოიყენება წარმატებული `Promise`-ს მნიშვნელობის დასაბრუნებლად.

წარმატებული შემთხვევის გარდა ასევე გვაქვს წარუმატებელი შემთხვევაც. წარუმატებელი შემთხვევის დროს გამოიყენება [`Promise.reject`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject), რომელიც იგივეა რაც `Promise.resolve` ოღონდ საპირისპიროდ.

განვიხილოთ მისი მაგალითიც:

```js
function isValidId(id) {
  return id.startsWith('#') && id.endsWith('#');
}

function placeOrder(id) {
  if (isValidId(id)) {
    return Promise.reject('არასწორი id ფორმატი');
  }

  return new Promise((resolve) => {
    // სიმულაცია შეკვეთის განთავსების
    setTimeout(() => {
      resolve(`შეკვეთა იდ ${id}-ით, წარმატებით განთავსდა`);
    }, 1000);
  });
}
```

ამ შემთხვევაში გვაქვს ორი ფუნქცია. პირველი ფუნქცია ამოწმებს ვალიდური არის თუ არა გადაცემული `id`, ხოლო მეორე ფუნქცია შეკვეთის სიმულაციისთვსი არის. არის მომენტები, როცა რაღაც შეცდომის გამო ფუნქციამ შესაძლოა მიიღოს არასწორი `id`, სანამ ჩანაწერს გავაკეთებთ უმჯობესია ყოველთვის მისი შემოწმება ვიდრე კლიენტისა და სერვერის რესურსებს დავხარჯავთ. წინასწარ `id`-ს შემოწმებით ვზოგავთ მოთხოვნის გაგზავნას, რაც დარწმუნებით ვიცით რომ შეცდომას წარმოქმნიდა.

`Promise`-ს კიდევ გააჩნია სხვა მეთოდებიც, რომელსაც განვიხილავთ შემდგომ თავში `async` და `await`-თან ერთად.

## შეჯამება

ასინქრონული მოქმედებების შესრულებისთვის შეგვიძლია გამოვიყენოთ `Promise`-ები, რომლისგანაც მეტწილადად ველოდებით ორ შედეგს: კარგს (წარმატებულად შესრულებულს) ან ცუდს (წარუმატებლად შესრულებულს).
