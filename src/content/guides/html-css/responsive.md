---
title: 'რესპონსიული ვებ დიზაინი'
description: 'რა არის რესპონსივი CSS-ში?'
keywords: 'Responsive web design, რესპონსიული ვებ დიზაინი, Responsive, რესპონსივი, რა არის რესპონსივი?, Media query, როგორ ავაწყოთ რესპონსიული ვებგვერდი?'
---

რესპონსიული ვებ დიზაინი (**R**esponsive **W**eb **D**esign) ეს არის ვებ დიზაინის მიდგომა, რომლის მიზანია
ვებგვერდების ისე აგება, რომ ისინი სწორად და კარგად გამოჩდნენ ყველა ზომისა და გარჩევადობის ეკრანზე, რაც უზრუნველყოფს
კარგ გამოყენებადობას. ამ სტატიაში განვიხილავთ ტექნიკებს, რომლებიც დაგეხმარებათ რესპონსიულ დიზაინის აგებაში.

## რესპონსიული დიზაინის წინამორბედი: მობილური ვებ დიზაინი

მანამდე, სანამ რესპონსიული ვებ დიზაინი სტანდარტულ მიდგომად იქცეოდა სხვადასხვა მოწყობილობაზე ვებსაიტების სწორად მუშაობისთვის,
ვებ დეველოპერები საუბრობდნენ მობილურ ვებ დიზაინზე ან ზოგჯერ მობილურისთვის მოსახერხებელ დიზაინზე (mobile friendly).
ეს ტერმინები ძირითადად იგივე მიზანს ემსახურებოდა, რაც რესპონსიული ვებ დიზაინი (RWD), რომელიც უზრუნველყფობს ვებსაიტების სწორად მუშაობას სხვადასხვა მოწყობილობებზე,
რომლებიც განსხვავდებიან ფიზიკური მახასიათებლებით (ეკრანის ზომა, გარჩევადობა) განლაგების, კონტენტის (ტექსტისა და მედიის) და წარმადობის თვალსაზრისით.

სხვაობა ძირითადად გამოყენებულ მოწყობილობებსა და იმ ტექნოლოგიებს ეხება, რომლებიც ამ პრობლემის გადასაჭრელად ხელმისაწვდომი იყო:

- ადრე ვსაუბრობდით მხოლოდ დესკტოპსა და მობილურზე მაგრამ დღესდღეობით არსებობს მოწყობილობების მრავალი ტიპი, როგორიცაა
  დესკტოპი, ლეპტოპი, მობილური, ტაბლეტი, სმარტსაათი და სხვა. თუ ადრე ვცდილობდით რამდენიმე განსხვავებული ეკრანის ზომისთვის
  გაგვეკეთებინა ადაპტაცია, დღეს საჭიროა მხოლოდ ვებსაიტის სწორი სტანდარტებით აწყობა, რომელიც მოერგება ნებისმიერ ზომასა და მოწყობილობას.
- მობილური მოწყობილობები ადრე შედარებით სუსტი მონაცემების იყო ([CPU](https://en.wikipedia.org/wiki/Central_processing_unit)/[GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit)),
  თანაც ნელი ინტერნეტით. ზოგიერთ მოწყობილობას არ ჰქონდა მხარდაჭერა არც CSS-ისთვის და ზოგჯერ არც HTML-ისთვისაც კი.
  ამის გამო, ხშირად გამოიყენებოდა სერვერის მხარეს ბრაუზერის ამოცნობა (Browser sniffing), რათა განესაზღვრა მოწყობილობის ან ბრაუზერის ტიპი
  და შემდეგ მიეწოდებინა შესაბამისი ვებსაიტის ვერსია, რომელსაც წარმატებით ჩართავდა. ასეთ შემთხვევაში, მობილურ მოწყობილობებზე ხშირად მხოლოდ
  ძალიან მარტივი და შეზღუდული ვერსია იტვირთებოდა, რადგან მეტი შესაძლებლობა მათ არ ჰქონდათ. დღეს კი მობილური მოწყობილობები იმდენად გამართულია,
  რომ შეუძლიათ იმავე ტექნოლოგიების გამოყენება, რაც კომპიუტერებს ამიტომ მსგავსი მიდგომები უკვე ნაკლებად გამოიყენება.
  - მიუხედავად იმისა, რომ თანამედროვე მობილური მოწყობილობები ტექნიკურად საკმაოდ ძლიერია, საჭიროა მაინც შესაბამისი ოპტიმიზაციის შესრულება მოწყობილობებისთვის.
  - UX (User experience) კვლავ მნიშვნოლოვანი საკითხია. მაგალითად, მომხარებელი იყენებს მობილურს, რომელიც სამოგზაურო ვებსაიტზე შედის, შესაძლოა უბრალოდ ფრენის
    დროისა და დაგვიანების შესახებ ინფორმაციის შემოწმება სურდეს და არა 3D ანიმირებული გლობუსის ნახვა, სადაც ფრენის მარშრუტებია და კომპანიის ისტორია.
- თანამედროვე ტექნოლოგიები გაცილებით უკეთეს შესაძლებლობას იძლევა რესპონსიული ვებგვერდების შესაქმნელად. მაგალითად,
  [რესპონსიული სურათებისა და მედიის ტექნოლოგიები](#რესპონსიული_სურათები/მედია) დღეს უკვე საშუალებას იძლევა სხვადასხვა მოწყობილობას მიეწოდოს შესაბამისი მედია,
  ყოველგვარი სერვერზე შემოწმების (sniffing) ტექნიკის გამოყენების გარეშე.

## Media Queries

[Media query](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries) (მედიის წაკითხვა)
საშუალებას გვაძლევს ჩავატაროთ სხვადასხვა ტესტი (მაგალითად, არის თუ არა მომხმარებლის ეკრანი გარკვეულ სიგანეს ან გარჩევადობას ზემოთ), რომელსაც შემდეგ გავსტილავთ CSS-ით.

მაგალითად დავსტილოთ ვებგვერდის ფონი შავად თუ მისი ეკრანის სიგანე (width) ნაკლებია `900px`-ზე.

```css
@media screen and (max-width: 900px) {
  body {
    background-color: black;
  }
}
```

ამ შემთხვევაში დაისტილება მომხარებლის ეკრანზე გამოსახული დიზაინი, ასევე შეგვიძლია მის ნაცვლად გამოვიყენოთ `print`, რომელიც მხოლოდ ამობეჭვდის დროს გამოისახება.

`@media` თვისების გამოყენება ფორმულა:

```css
@media media_type and (media_feature) {
  /* სტილები */
}
```

- `media_type` შეიძლება იყოს: `all`, `print` ან `screen`.
- `and` გამოიყენება ერთი ან რამდენიმე თვისების გასაერთიანებლად.
- `media_feature` შეიძლება იყოს: [`any-hover`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/any-hover), [`any-pointer`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/any-pointer), [`aspect-ratio`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/aspect-ratio), [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color), [`color-gamut`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-gamut), [`color-index`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-index), [`device-posture`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-posture), [`display-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/display-mode), [`dynamic-range`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/dynamic-range), [`forced-colors`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors), [`grid`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/grid), [`height`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/height), [`hover`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/hover), [`inverted-colors`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/inverted-colors), [`monochrome`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/monochrome), [`orientation`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/orientation), [`overflow-block`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-block), [`overflow-inline`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-inline), [`pointer`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer), [`prefers-color-scheme`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), [`prefers-contrast`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast), [`prefers-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion), [`prefers-reduced-transparency`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-transparency), [`resolution`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/resolution), [`scripting`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/scripting), [`update`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/update), [`video-dynamic-range`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/video-dynamic-range), [`width`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/width).

მაგალითები:

```css
@media print {
  /* ამობეჭვდისთვის განკუთვნილი სტილები */
}
```

```css
@media screen, print {
  /* ეკრანზე და ამობეჭვდისთვის განკუთვნილი სტილები */
}
```

თუმცა მათი გაერთიანების ჩაწერა უფრო მარტივად შეიძლება `all`-ის გამოყენებით:

```css
@media all {
  /* ორივე მედიის ტიპის გაერთიანება */
}
```

### ეკრანის ზომიდან გამომდინარე სტილები

ხშირ შემთხვევაში, როცა რესპონსიული ვებ დიზაინის შექმნაზე მუშაობთ, დაგჭირდებათ ეკრანის ზომიდან გამომდინარე სტილების ცვლილებები.
მაგალითად, გვსურს შევცვალოთ თანმიმდევრობა ელემენტების ზომიდან გამომდინარე.

```css
@media screen and (max-width: 1024px) {
  .some_container .child {
    order: 1;
  }
}
```

ადრე სავალდებულო იყო `max-width`-ისა და `min-width`-ის გაწერა.
ახლა უფრო მარტივად შეგვიძლია იგივე სტილების ჩაწერა:

```css
@media screen and (width <= 1024px) {
  .some_container .child {
    order: 1;
  }
}
```

ხოლო `min-width`-ის შემთხვევაში:

```css
@media (min-width: 1024px) {
  /* სტილები, როცა ეკრანის ზომა 1024px-ზე მეტია */
}
```

```css
@media (min-width >= 1024px) {
  /* სტილები, როცა ეკრანის ზომა 1024px-ზე მეტია */
}
```

ასევე შეგვიძლია სპეციფიკურად დავსტილოთ, როცა ერკანის ზომა მოქცეულია შესაბამის ზომებში:

```css
@media (min-width: 500px) and (max-width: 800px) {
  /* … */
}

@media (500px <= width <= 800px) {
  /* … */
}

@media (800px >= width >= 500px) {
  /* … */
}
```

:::info
ზოგადად არ არის სავალდებულო `screen`-ის წერა, ნაგულისხმევად ისეც `screen` იქნება.
:::

ახალი სინტაქსით შეგვიძლია, როგორც `<=`, `>=` ასევე `<`, `>` გამოყენება.

## რესპონსიული განლაგების ტექნოლოგიები

რესპონსიული განლაგებისთვის შეგიძლიათ გამოიყენოთ [ფლექსბოქსები](./doc/guides/html-css/flexbox) და [გრიდები](./doc/guides/html-css/grid).

ნაგულისხმევად ორივე ტექნოლოგიას გააჩნიათ რამდენიმე თვისება, რომელიც განსაზღვრავს რესპონსიულობას.
თუმცა ხშირად მაინც საჭიროა კონკრეტულ ეკრანის ზომაზე სტილიზაციის მორგება.

### Flexbox

Flexbox-ში ელემენტები ([flex items](./doc/guides/html-css/flexbox#Flex_Item)) ავტომატურად იზრდებიან ან იკუმშებიან, იმის მიხედვით, რამდენი სივრცეა ხელმისაწვდომი მათ მშობელ კონტეინერში.
[`flex-grow`](./doc/guides/html-css/flexbox#flex-grow) და [`flex-shrink`](./doc/guides/html-css/flexbox#flex-shrink) პარამეტრების შეცვლით შეგიძლიათ განსაზღვროთ,
როგორ უნდა მოიქცნენ ეს ელემენტები მაშინ, როცა მეტი ან ნაკლები ადგილი აქვთ ირგვლივ.

ქვემოთ მოცემულ მაგალითში, თითოეული ელემენტი კონტეინერში თანაბარ სივრცეს დაიკავებს.
ამისათვის გამოყენებულია შემოკლებული ჩანაწერი `flex: 1`, რაც უკვე განხილულია თემაში [შემოკლებული ვარიანტი: flex](./doc/guides/html-css/flexbox#შემოკლებული_ვარიანტი:_flex).

```html preview
<div class="wrapper">
  <div class="col1">
    <p>ეს განლაგება რესპონსიულია. სცადეთ დააპატარავოთ ან გაადიდოთ ბრაუზერის ფანჯარა და ნახეთ, რა მოხდება.</p>
  </div>
  <div class="col2">
    <p>HTML (HyperText Markup Language - ჰიპერტექსტური მარკაპის ენა) არის მარკაპის ენა, რომელიც მუითებებს ბრაუზერს, თუ როგორი სტრუქტურა მისცეს ვებგვერდს. HTML-ში გამოიყენება ელემენტები, რომ ტექსტური კონტენტი შევკრათ ან მოვნიშნოთ (mark up), რათა ამ კონტენტს გარკვეული გარეგნობა, ქცევა ან დანიშნულება შეეძინოს.</p>
    <p>HTML შედგება ელემენტებისგან, რომლებიც გამოიყენება კონტენტის სხვადასხვა ნაწილის შესაფუთად, რათა მას მიენიჭოს განსხვავებული გარეგნობა ან დანიშნულება. ნიმუშად ავიღოთ მარტივი ტექსტი, რომელსაც მარკაპს გავუკეთებთ: მე მინდა ვისწავლო მეტი!</p>
  </div>
</div>
```

```css preview
.container {
  display: flex;
}

.item {
  flex: 1;
}

@media (width >= 600px) {
  .wrapper {
    display: flex;
  }

  .col1 {
    flex: 1;
    margin-right: 5%;
  }

  .col2 {
    flex: 2;
  }
}
```

დააპატარავეთ ან გაადიდეთ ბრაუზერის ფანჯარა. როცა ზემოთ მოცემული მაგალითის სიგანე გადაცდება `600` პიქსელის ზღვარს,
განლაგება გადართავს ერთსვეტიანიდან ორსვეტიან რეჟიმზე.

### CSS grid

CSS Grid განლაგებაში `fr` ერთეული საშუალებას იძლევა ხელმისაწვდომი სივრცე გადანაწილდეს გიდის ტრეკებს შორის.
შემდეგი მაგალითი ქმნის გიდ კონტეინერს სამი ტრეკით, რომელთაგან თითოეული ზომაში არის `1fr`.
ეს ნიშნავს, რომ შეიქმნება სამი სვეტი, რომლებიც კონტეინერის სივრცეს თანაბრად გაინაწილებენ. ამ მიდგომას უკვე გაეცანით
[CSS grid](./doc/guides/html-css/grid#fr_მნიშვნელობა)-ის სტატიაში.

```html preview
<div class="wrapper">
  <div class="col1">
    <p>ეს განლაგება რესპონსიულია. სცადეთ დააპატარავოთ ან გაადიდოთ ბრაუზერის ფანჯარა და ნახეთ, რა მოხდება.</p>
  </div>
  <div class="col2">
    <p>HTML (HyperText Markup Language - ჰიპერტექსტური მარკაპის ენა) არის მარკაპის ენა, რომელიც მუითებებს ბრაუზერს, თუ როგორი სტრუქტურა მისცეს ვებგვერდს. HTML-ში გამოიყენება ელემენტები, რომ ტექსტური კონტენტი შევკრათ ან მოვნიშნოთ (mark up), რათა ამ კონტენტს გარკვეული გარეგნობა, ქცევა ან დანიშნულება შეეძინოს.</p>
    <p>HTML შედგება ელემენტებისგან, რომლებიც გამოიყენება კონტენტის სხვადასხვა ნაწილის შესაფუთად, რათა მას მიენიჭოს განსხვავებული გარეგნობა ან დანიშნულება. ნიმუშად ავიღოთ მარტივი ტექსტი, რომელსაც მარკაპს გავუკეთებთ: მე მინდა ვისწავლო მეტი!</p>
  </div>
</div>
```

```css preview
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
}

@media (width >= 600px) {
  .wrapper {
    display: grid;
    grid-template-columns: 1fr 2fr;
    column-gap: 5%;
  }
}
```

დააპატარავეთ ან გაადიდეთ ბრაუზერის ფანჯარა. როცა ზემოთ მოცემული მაგალითის სიგანე გადაცდება `600` პიქსელის ზღვარს,
განლაგება გადართავს ერთსვეტიანიდან ორსვეტიან რეჟიმზე.

## რესპონსიული სურათები/მედია

იმისათვის, რომ მედია არასოდეს აღემატებოდეს მის რესპონსიურ კონტეინერს, შეიძლება გამოვიყენოთ შემდეგი მიდგომა:

```css
img,
picture,
video {
  max-width: 100%;
}
```

## რესპონსიული ტიპოგრაფია

რესპონსიული ტიპოგრაფია გულისხმობს ფონტის ზომების ცვლილებას ეკრანის ზომიდან გამომდინარე.

### Media query-ს გამოყენება რესპონსიული ტიპოგრაფიისთვის

ამ მაგალითში, გვსურს, რომ ჩვენი პირველი სათაურის ელემენტი იყოს `4rem`, რაც ჩვენი საწყისი ფონტის
ზომის ოთხმაგს ნიშნავს. ეს საკმაოდ დიდი სთაურია! ჩვენ გვინდა ასეთი დიდი სათაური მხოლოდ დიდ ეკრანებზე იყოს გამოყენებული.
ამიტომ თავდაპირველ ზომას გავუწეროთ `2rem` ხოლო შემდეგ `4rem`, როცა ეკრანის ზომა `1200px`-ზე დიდია.

```html preview
<h1>დაუკვირდი ჩემს ზომას</h1>
<p>სხვა ტექსტი შესადარებლად</p>
```

```css preview
html {
  font-size: 1em;
}

h1 {
  font-size: 2rem;
}

@media (width >= 1200px) {
  h1 {
    font-size: 4rem;
  }
}
```

როცა ეკრანის ზომა `1200px`-ზე დიდი იქნება მხოლოდ მაშინ მიიღებს დიდ ზომას.
თუმცა ეს მიდგომა მოითხოვს სხვადასხვა ეკრანის ზომაზე, სხვადასხვა ფონტის ზომის მინიჭებას.
შეგვიძლია ეკრანის დაპატარავებასთან ერთად, ფონტის ზომაც დინამიურად ვცვალოთ.

### რესპონსიული ტიპოგრაფიისთვის viewport ერთეულების გამოყენება

Viewport-ის ერთეული `vw` ასევე გამოიყენება რესპონსიული ტიპოგრაფიისთვის, Media query-ის ბრეიქპოინტების (პიქსელებში მინიჭებული მნიშვნელობა) დაყენების გარეშე.
`1vw` შეადგენს viewport-ის (ეკრანის) სიგანის 1%-ს, რაც ნიშნავს, რომ თუ ფონტის ზომას `vw` ერთეულში დააყენებთ, ის ყოველთვის იქნება დამოკიდებული ეკრანის ზომაზე.

```html preview
<h1>დაუკვირდი ჩემს ზომას</h1>
<p>სხვა ტექსტი შესადარებლად</p>
```

```css preview
h1 {
  font-size: 2vw;
}
```

### calc

როგორ მოვიქცეთ თუ გვსურს მინიმალურად, რაღაც საწყისი ზომის მინიჭება? ამისათვის შეგვიძლია გამოვიყენოთ [`calc()`](https://developer.mozilla.org/en-US/docs/Web/CSS/calc) ფუნქცია.

```css
h1 {
  font-size: calc(2vw + 16px);
}
```

ასე მივიღებთ ეკრანის ზომის ორ პროცენტს დამატებული `16px`.

### clamp

თუ გვსურს ფონტის ზომის მინიმალურ და მაქსიმალურ ზომაში მოთავსება მაშინ შეგვიძლია გამოვიყენოთ [`clamp()`](https://developer.mozilla.org/en-US/docs/Web/CSS/clamp) ფუნქცია.

მისი ფორმულა შემდეგია:

```css
h1 {
  font-size: clamp(მინიმუმი_ზომა, სასურველი_ზომა, მაქსიმალური_ზომა);
}
```

```html preview
<h1>დაუკვირდი ჩემს ზომას</h1>
<p>სხვა ტექსტი შესადარებლად</p>
```

```css preview
h1 {
  font-size: clamp(16px, 3vw, 40px);
}
```

მსგავს ტიპად განვსაზღვრავთ, რომ ფონტის ზომა მინიმალურად იყოს `16px` ხოლო მაქსიმალურად `40px`. ეკრანის დაპატარავებიდან გამომდიანრე დინამიურად შეიცვლება მისი ზომაც.

:::error
თავი აარიდეთ სტატიკური მნიშვნელობების გამოყენებას.
თუ გამოიყენებთ შეამოწმეთ მისი გამოყენება სხვადასხვა ეკრანის ზომაზე!
:::

## viewport მეტა თეგი

თუ დააკვირდებით რესპონსიული გვერდის HTML კოდს, ჩვეულებრივ, დოკუმენტის `<head>` ნაწილში ნახავთ შემდეგ `<meta>` ტეგს:

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

ეს viewport მეტა თეგი ეუბნება მობილურ ბრაუზერებს, რომ უნდა დააყენონ [viewport](./doc/guides/html-css/seo#მეტა_თეგები)-ის სიგანე მოწყობილობის სიგანის შესაბამისად
და მასშტაბირება მოახდინონ დოკუმენტისა 100%-ზე, რომელიც დოკუმენტს აჩვენებს იმ მობილურზე ოპტიმიზირებულ ზომაში, როგორზეც ის იყო განკუთვნილი.

რატომ არის ეს საჭირო? იმიტომ, რომ მობილური ბრაუზერები ხშირად არ ასახავენ სწორად თავიანთი viewport-ის სიგანეს.

ეს მეტა თეგი არსებობს იმიტომ, რომ როცა სმარტფონები პირველად გამოჩნდა, ვებსაიტების უმეტესობა მობილურზე ოპტიმიზირებული არ იყო.
ამიტომ, მობილური ბრაუზერები აყენებდნენ viewport-ის სიგანეს 980 პიქსელზე, ამ სიგანით რენდერდებოდა (გამოისახებოდა) გვერდი და შედეგი ნაჩვენები იყო,
როგორც გადიდებული desktop განლაგების შემცირებული ვერსია. მომხმარებლებს შეეძლოთ გადიდება და გვერდზე გადაადგილება, რომ დაენახათ საინტერესო ნაწილები,
მაგრამ ვიზუალურად ეს ცუდად გამოიყურებოდა.

როდესაც აწესებთ `width=device-width`, ამით ცვლით მობილური მოწყობილობის ნაგულისხმევ მნიშვნელობას, მაგალითად iPhone-ის `width=980px`,
მოწყობილობის ფაქტობრივი სიგანით. მის გარეშე, თქვენი რესპონსიული დიზაინი breakpoint და media query შესაძლოა მობილურ ბრაუზერებზე არ იმუშაოს სწორად.

ამიტომ ყოველთვის უნდა ჩართოთ viewport მეტა თეგი დოკუმენტის `head` ნაწილში.

## შეჯამება

ამ სტატიაში განვიხილეთ რესპონსიული ვებ დიზაინის (RWD) მნიშვნილობა, ტექნიკები და თანამედროვე მიდგომები.

## გამოყენებული ლიტერატურა

- [Responsive web design](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/CSS_layout/Responsive_Design)
