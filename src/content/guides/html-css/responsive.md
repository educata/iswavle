---
title: 'რესპონსიული ვებ დიზაინი'
description: 'რა არის რესპონსივი CSS-ში?'
keywords: 'Responsive web design, რესპონსიული ვებ დიზაინი, Responsive, რესპონსივი, რა არის რესპონსივი?, Media query, როგორ ავაწყოთ რესპონსიული ვებგვერდი?'
---

რესპონსიული ვებ დიზაინი (**R**esponsive **W**eb **D**esign) ეს არის ვებ დიზაინის მიდგომა, რომლის მიზანია
ვებგვერდების ისე აგება, რომ ისინი სწორად და კარგად გამოჩდნენ ყველა ზომისა და გარჩევადობის ეკრანზე, რაც უზრუნველყოფს
კარგ გამოყენებადობას. ამ სტატიაში განვიხილავთ ტექნიკებს, რომლებიც დაგეხმარებათ რესპონსიული დიზაინის აგებაში.

## რესპონსიული დიზაინის წინამორბედი: მობილური ვებ დიზაინი

იქამდე, სანამ რესპონსიული ვებ დიზაინი სტანდარტულ მიდგომად იქცეოდა, სხვადასხვა მოწყობილობაზე ვებსაიტების სწორად მუშაობისთვის,
ვებ დეველოპერები საუბრობდნენ მობილურ ვებ დიზაინზე ან ზოგჯერ მობილურისთვის მოსახერხებელ დიზაინზე (mobile friendly).
ეს ტერმინები ძირითადად იგივე მიზანს ემსახურებოდა, რასაც რესპონსიული ვებ დიზაინი (RWD), რომელიც უზრუნველყფობს ვებსაიტების სწორად მუშაობას სხვადასხვა მოწყობილობებზე.
ისინი განსხვავდებიან ფიზიკური მახასიათებლებით (ეკრანის ზომა, გარჩევადობა) განლაგების, კონტენტის (ტექსტისა და მედიის) და წარმადობის თვალსაზრისით.

სხვაობა ძირითადად გამოყენებულ მოწყობილობებსა და იმ ტექნოლოგიებს ეხება, რომლებიც ამ პრობლემის გადასაჭრელად ხელმისაწვდომი იყო:

- ადრე ვსაუბრობდით მხოლოდ დესკტოპსა და მობილურზე, მაგრამ დღესდღეობით არსებობს მოწყობილობების მრავალი ტიპი, როგორიცაა
  დესკტოპი, ლეპტოპი, მობილური, ტაბლეტი, სმარტსაათი და სხვა. თუ ადრე ვცდილობდით რამდენიმე განსხვავებული ეკრანის ზომისთვის
  დიზაინის მორგებას, დღეს საჭიროა ისეთი სტანდარტებით ხელმძღვანელობა, რომელიც მოერგება ნებისმიერი ზომისა და ფორმის მოწყობილობას.
- მობილური მოწყობილობებს ადრე გააჩნდათ შედარებით სუსტი ([CPU](https://en.wikipedia.org/wiki/Central_processing_unit)/[GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit))
  და ნელი ინტერნეტი. ზოგიერთ მოწყობილობას არ ჰქონდა მხარდაჭერა არც CSS-ისთვის და ზოგჯერ არც HTML-ისთვისაც კი.
  ამის გამო, ხშირად გამოიყენებოდა სერვერის მხარეს ბრაუზერის ამოცნობა (Browser sniffing), რათა სერვერს განესაზღვრა მოწყობილობის ან ბრაუზერის ტიპი
  და შემდეგ მიეწოდებინა შესაბამისი ვებსაიტის ვერსია, რომელსაც კლიენტი წარმატებით ჩართავდა. ასეთ შემთხვევაში, მობილურ მოწყობილობებზე ხშირად მხოლოდ
  ძალიან მარტივი და შეზღუდული საიტის ვერსია იტვირთებოდა, რადგან მეტი შესაძლებლობა მათ არ ჰქონდათ. დღეს მობილური მოწყობილობები იმდენად მძლავრია,
  რომ შეუძლიათ იმავე ტექნოლოგიების გამოყენება, რაც კომპიუტერებს, ამიტომ მსგავსი მიდგომები უკვე ნაკლებად გამოიყენება.
  - მიუხედავად იმისა, რომ თანამედროვე მობილური მოწყობილობები ტექნიკურად საკმაოდ ძლიერია, საჭიროა მაინც საჭიროა მათი თავისებურებების გათვალისწინება.
  - UX (User experience) კვლავ მნიშვნოლოვანი საკითხია. მაგალითად, მომხარებელი მობილური მოწყობილობით ავიახაზების ვებსაიტზე შედის, სადაც უბრალოდ ფრენის
    დროისა და დაგვიანების შესახებ ინფორმაციის შემოწმება სურს და არა 3D ანიმირებული გლობუსის ნახვა, სადაც ფრენის მარშრუტები და კომპანიის ისტორიაა.
- თანამედროვე ტექნოლოგიები გაცილებით უკეთეს შესაძლებლობას იძლევა რესპონსიული ვებგვერდების შესაქმნელად. მაგალითად,
  [რესპონსიული სურათებისა და მედიის ტექნოლოგიები](#რესპონსიული_სურათები/მედია) დღეს უკვე საშუალებას იძლევა, სხვადასხვა მოწყობილობას მიეწოდოს შესაბამისი მედია,
  ყოველგვარი სერვერზე შემოწმების (sniffing) ტექნიკის გამოყენების გარეშე.

## Media Queries

[Media query](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries) (მედიის წაკითხვა)
საშუალებას გვაძლევს, შევამოწმოთ მოწყობილობის გარკვეული მდგომარეობა
(მაგალითად, არის თუ არა მომხმარებლის ეკრანი გარკვეულ სიგანეს ან გარჩევადობას ზემოთ, არის თუ არა მოწყობილობა ვერტიკალური ან ჰორიზონტალური ორიენტაციის და ა.შ),
რომელზე დაყრდნობითაც შემდეგ აპლიკაციას გავსტილავთ.

მაგალითად, დავსტილოთ ვებგვერდის ფონი შავად, თუ მისი ეკრანის სიგანე (width) ნაკლებია `900px`-ზე.

```css
@media screen and (max-width: 900px) {
  body {
    background-color: black;
  }
}
```

ამ შემთხვევაში დაისტილება მომხარებლის ეკრანზე გამოსახული დიზაინი, ასევე შეგვიძლია მის ნაცვლად გამოვიყენოთ `print`, რომელიც მხოლოდ ამობეჭვდის დროს გამოისახება.

`@media` თვისების გამოყენება ფორმულა:

```css
@media media_type and (media_feature) {
  /* სტილები */
}
```

- `media_type` შეიძლება იყოს: `all`, `print` ან `screen`.
- `and` გამოიყენება ერთი ან რამდენიმე თვისების გასაერთიანებლად.
- `media_feature` შეიძლება იყოს: [`any-hover`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/any-hover), [`any-pointer`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/any-pointer), [`aspect-ratio`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/aspect-ratio), [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color), [`color-gamut`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-gamut), [`color-index`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-index), [`device-posture`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-posture), [`display-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/display-mode), [`dynamic-range`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/dynamic-range), [`forced-colors`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors), [`grid`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/grid), [`height`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/height), [`hover`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/hover), [`inverted-colors`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/inverted-colors), [`monochrome`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/monochrome), [`orientation`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/orientation), [`overflow-block`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-block), [`overflow-inline`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-inline), [`pointer`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer), [`prefers-color-scheme`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), [`prefers-contrast`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast), [`prefers-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion), [`prefers-reduced-transparency`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-transparency), [`resolution`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/resolution), [`scripting`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/scripting), [`update`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/update), [`video-dynamic-range`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/video-dynamic-range), [`width`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/width).

მაგალითები:

```css
@media print {
  /* ამობეჭვდისთვის განკუთვნილი სტილები */
}
```

```css
@media screen, print {
  /* ეკრანზე და ამობეჭვდისთვის განკუთვნილი სტილები */
}
```

თუმცა მათი გაერთიანების ჩაწერა უფრო მარტივად შეიძლება `all`-ის გამოყენებით:

```css
@media all {
  /* ორივე მედიის ტიპის გაერთიანება */
}
```

### ეკრანის ზომიდან გამომდინარე სტილები

ხშირ შემთხვევაში, როცა რესპონსიული ვებ დიზაინის შექმნაზე მუშაობთ, დაგჭირდებათ ეკრანის ზომიდან გამომდინარე სტილების ცვლილებები.
მაგალითად, გვსურს შევცვალოთ თანმიმდევრობა ელემენტების ზომიდან გამომდინარე.

```css
@media screen and (max-width: 1024px) {
  .some_container .child {
    order: 1;
  }
}
```

ადრე სავალდებულო იყო `max-width`-ისა და `min-width`-ის გაწერა.
ახლა უფრო მარტივად შეგვიძლია იგივე სტილების ჩაწერა:

```css
@media screen and (width <= 1024px) {
  .some_container .child {
    order: 1;
  }
}
```

ხოლო `min-width`-ის შემთხვევაში:

```css
@media (min-width: 1024px) {
  /* სტილები, როცა ეკრანის ზომა 1024px-ზე მეტია */
}
```

```css
@media (min-width >= 1024px) {
  /* სტილები, როცა ეკრანის ზომა 1024px-ზე მეტია */
}
```

ასევე შეგვიძლია სპეციფიკურად დავსტილოთ დოკუმენტი, როცა ერკანის ზომა მოქცეულია გარკვეული ზომის ფარგლებში:

```css
@media (min-width: 500px) and (max-width: 800px) {
  /* … */
}

@media (500px <= width <= 800px) {
  /* … */
}

@media (800px >= width >= 500px) {
  /* … */
}
```

:::info
ზოგადად არ არის სავალდებულო `screen`-ის წერა, რადგან ის ნაგულსხმევი მნიშვნელობაა.
:::

ახალი სინტაქსით შეგვიძლია, როგორც `<=`-ისა და `>=`-ის, ასევე `<`-ისა და `>`-ის გამოყენება.

## რესპონსიული განლაგების ტექნოლოგიები

რესპონსიული განლაგებისთვის შეგიძლიათ გამოიყენოთ [ფლექსბოქსები](./doc/guides/html-css/flexbox) და [გრიდები](./doc/guides/html-css/grid).

ნაგულისხმევად ორივე ტექნოლოგიას გააჩნია რამდენიმე თვისება, რომელიც განსაზღვრავს რესპონსიულობას.
თუმცა ხშირად მაინც საჭიროა კონკრეტულ ეკრანის ზომაზე სტილიზაციის მორგება.

### Flexbox

Flexbox-ში ელემენტები ([flex items](./doc/guides/html-css/flexbox#Flex_Item)) ავტომატურად იზრდებიან ან იკუმშებიან, იმის მიხედვით, რამდენი სივრცეა ხელმისაწვდომი მათ მშობელ კონტეინერში.
[`flex-grow`](./doc/guides/html-css/flexbox#flex-grow) და [`flex-shrink`](./doc/guides/html-css/flexbox#flex-shrink) პარამეტრების შეცვლით შეგიძლიათ განსაზღვროთ,
როგორ უნდა მოიქცნენ ეს ელემენტები მაშინ, როცა მეტი ან ნაკლები ადგილი აქვთ ირგვლივ.

ქვემოთ მოცემულ მაგალითში, თითოეული ელემენტი კონტეინერში თანაბარ სივრცეს დაიკავებს.
ამისათვის გამოყენებულია შემოკლებული ჩანაწერი `flex: 1`, რომელიც დეტალურად უკვე განხილულია [ფლექსბოქსის სტატიაში](./doc/guides/html-css/flexbox#შემოკლებული_ვარიანტი:_flex).

```html preview
<div class="wrapper">
  <div class="col1">
    <p>ეს განლაგება რესპონსიულია. სცადეთ დააპატარავოთ ან გაადიდოთ ბრაუზერის ფანჯარა და ნახეთ, რა მოხდება.</p>
  </div>
  <div class="col2">
    <p>HTML (HyperText Markup Language - ჰიპერტექსტური მარკაპის ენა) არის მარკაპის ენა, რომელიც მუითებებს ბრაუზერს, თუ როგორი სტრუქტურა მისცეს ვებგვერდს. HTML-ში გამოიყენება ელემენტები, რომ ტექსტური კონტენტი შევკრათ ან მოვნიშნოთ (mark up), რათა ამ კონტენტს გარკვეული გარეგნობა, ქცევა ან დანიშნულება შეეძინოს.</p>
    <p>HTML შედგება ელემენტებისგან, რომლებიც გამოიყენება კონტენტის სხვადასხვა ნაწილის შესაფუთად, რათა მას მიენიჭოს განსხვავებული გარეგნობა ან დანიშნულება. ნიმუშად ავიღოთ მარტივი ტექსტი, რომელსაც მარკაპს გავუკეთებთ: მე მინდა ვისწავლო მეტი!</p>
  </div>
</div>
```

```css preview
.container {
  display: flex;
}

.item {
  flex: 1;
}

@media (width >= 600px) {
  .wrapper {
    display: flex;
  }

  .col1 {
    flex: 1;
    margin-right: 5%;
  }

  .col2 {
    flex: 2;
  }
}
```

დააპატარავეთ ან გაადიდეთ ბრაუზერის ფანჯარა. როცა ზემოთ მოცემული მაგალითის სიგანე გადაცდება `600` პიქსელის ზღვარს,
განლაგება გადაირთვება ერთსვეტიანიდან ორსვეტიან რეჟიმზე.

### CSS grid

CSS Grid განლაგებაში `fr` ერთეული საშუალებას იძლევა, ხელმისაწვდომი სივრცე გადანაწილდეს გრიდის ბილიკებს შორის.
შემდეგი მაგალითი ქმნის გრიდ კონტეინერს სამი ბილიკით, სადაც თითოეული შვილობილი ელემებტი ზომაში არის `1fr`.
ეს ნიშნავს, რომ შეიქმნება სამი სვეტი, რომლებიც კონტეინერის სივრცეს თანაბრად გაინაწილებენ. ამ მიდგომას უკვე გაეცანით
[CSS grid](./doc/guides/html-css/grid#fr_მნიშვნელობა)-ის სტატიაში.

```html preview
<div class="wrapper">
  <div class="col1">
    <p>ეს განლაგება რესპონსიულია. სცადეთ დააპატარავოთ ან გაადიდოთ ბრაუზერის ფანჯარა და ნახეთ, რა მოხდება.</p>
  </div>
  <div class="col2">
    <p>HTML (HyperText Markup Language - ჰიპერტექსტური მარკაპის ენა) არის მარკაპის ენა, რომელიც მუითებებს ბრაუზერს, თუ როგორი სტრუქტურა მისცეს ვებგვერდს. HTML-ში გამოიყენება ელემენტები, რომ ტექსტური კონტენტი შევკრათ ან მოვნიშნოთ (mark up), რათა ამ კონტენტს გარკვეული გარეგნობა, ქცევა ან დანიშნულება შეეძინოს.</p>
    <p>HTML შედგება ელემენტებისგან, რომლებიც გამოიყენება კონტენტის სხვადასხვა ნაწილის შესაფუთად, რათა მას მიენიჭოს განსხვავებული გარეგნობა ან დანიშნულება. ნიმუშად ავიღოთ მარტივი ტექსტი, რომელსაც მარკაპს გავუკეთებთ: მე მინდა ვისწავლო მეტი!</p>
  </div>
</div>
```

```css preview
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
}

@media (width >= 600px) {
  .wrapper {
    display: grid;
    grid-template-columns: 1fr 2fr;
    column-gap: 5%;
  }
}
```

დააპატარავეთ ან გაადიდეთ ბრაუზერის ფანჯარა. როცა ზემოთ მოცემული მაგალითის სიგანე გადაცდება `600` პიქსელის ზღვარს,
განლაგება გადაირთვება ერთსვეტიანიდან ორსვეტიან რეჟიმზე.

## რესპონსიული სურათები/მედია

ჩვეულებრივ, მედია გამოისახება იმ ზომით, რა ზომაც გააჩნია მის კონტენტს, მაგალითად 1200 პიქსელის სიგანის სურათი `<img>` თეგში იქნება ავტომატურად 1200 პიქსელის სიგანის.
ეს ბუნებრივია, შექმნის რესპონსიულობის პრობლემებს.
იმისათვის, რომ მედია არასოდეს აღემატებოდეს მის რესპონსიურ კონტეინერს, შეიძლება გამოვიყენოთ შემდეგი მიდგომა:

```css
img,
picture,
video {
  max-width: 100%;
}
```

## რესპონსიული ტიპოგრაფია

რესპონსიული ტიპოგრაფია გულისხმობს ფონტის ზომების ცვლილებას ეკრანის ზომიდან გამომდინარე.

### Media query-ს გამოყენება რესპონსიული ტიპოგრაფიისთვის

ამ მაგალითში, გვსურს, რომ ჩვენი პირველი სათაურის ელემენტი იყოს `4rem`, რაც ჩვენი საწყისი ფონტის
ზომის ოთხმაგს ნიშნავს. ეს საკმაოდ დიდი სთაურია! ჩვენ გვინდა ასეთი დიდი სათაური მხოლოდ დიდ ეკრანებზე იყოს გამოყენებული.
ამიტომ თავდაპირველ ზომას გავუწეროთ `2rem`, ხოლო შემდეგ `4rem`, როცა ეკრანის ზომა `1200px`-ზე დიდია.

```html preview
<h1>დაუკვირდი ჩემს ზომას</h1>
<p>სხვა ტექსტი შესადარებლად</p>
```

```css preview
html {
  font-size: 1em;
}

h1 {
  font-size: 2rem;
}

@media (width >= 1200px) {
  h1 {
    font-size: 4rem;
  }
}
```

როცა ეკრანის ზომა `1200px`-ზე დიდი იქნება, მხოლოდ მაშინ დავინახავთ სათაურის გადიდებულ ვერსიას.
თუმცა ეს მიდგომა მოითხოვს სხვადასხვა ეკრანის ზომაზე სხვადასხვა ფონტის ზომის მინიჭებას.
შეგვიძლია ეკრანის დაპატარავებასთან ერთად, ფონტის ზომაც დინამიურად ვცვალოთ.

### რესპონსიული ტიპოგრაფიისთვის viewport ერთეულების გამოყენება

Viewport-ის ერთეული `vw` ასევე გამოიყენება რესპონსიული ტიპოგრაფიისთვის, Media query-ის ბრეიქპოინტების (პიქსელებში მინიჭებული მნიშვნელობა) დაყენების გარეშე.
`1vw` შეადგენს viewport-ის (ეკრანის) სიგანის 1%-ს, რაც ნიშნავს, რომ თუ ფონტის ზომას `vw` ერთეულში დააყენებთ, ის ყოველთვის იქნება დამოკიდებული ეკრანის ზომაზე.

```html preview
<h1>დაუკვირდი ჩემს ზომას</h1>
<p>სხვა ტექსტი შესადარებლად</p>
```

```css preview
h1 {
  font-size: 2vw;
}
```

### calc

როგორ მოვიქცეთ თუ გვსურს მინიმალურად რაღაც საწყისი ზომის მინიჭება? ამისათვის შეგვიძლია გამოვიყენოთ [`calc()`](https://developer.mozilla.org/en-US/docs/Web/CSS/calc) ფუნქცია.

```css
h1 {
  font-size: calc(2vw + 16px);
}
```

ასე მივიღებთ ეკრანის ზომის ორ პროცენტს დამატებული `16px`.

### clamp

თუ გვსურს ფონტის ზომის მინიმალურ და მაქსიმალურ ზომაში მოთავსება მაშინ შეგვიძლია გამოვიყენოთ [`clamp()`](https://developer.mozilla.org/en-US/docs/Web/CSS/clamp) ფუნქცია.

მისი ფორმულა შემდეგია:

```css
h1 {
  font-size: clamp(მინიმუმი_ზომა, სასურველი_ზომა, მაქსიმალური_ზომა);
}
```

```html preview
<h1>დაუკვირდი ჩემს ზომას</h1>
<p>სხვა ტექსტი შესადარებლად</p>
```

```css preview
h1 {
  font-size: clamp(16px, 3vw, 40px);
}
```

ასე განვსაზღვრავთ, რომ ფონტის ზომა იყოს არაუმცირეს `16px`-ისა და არაუდიდეს `40px`-ისა, ხოლო ამ ზომების ინტერვალში ფონტის ზომა იქნება `3vw`.
ეკრანის დაპატარავებიდან გამომდიანრე დინამიურად შეიცვლება მისი ზომაც.

:::error
თავი აარიდეთ სტატიკური მნიშვნელობების გამოყენებას.
საპირისპირო შემთხვევაში, შეამოწმეთ მისი გამოყენება სხვადასხვა ეკრანის ზომაზე!
:::

## viewport მეტა თეგი

თუ დააკვირდებით რესპონსიული გვერდის HTML კოდს, ჩვეულებრივ, დოკუმენტის `<head>` ნაწილში ნახავთ შემდეგ `<meta>` თეგს:

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

ეს viewport მეტა თეგი ეუბნება მობილურ ბრაუზერებს, რომ უნდა დააყენონ [viewport](./doc/guides/html-css/seo#მეტა_თეგები)-ის სიგანე მოწყობილობის სიგანის შესაბამისად
და დოკუმენტი გამოსახონ ზომის ცვლილების გარეშე, 1.0 სკალით. ასე დოკუმენტი მობილურზე გამოისახება ოპტიმიზირებულ ზომაში.

რატომ არის ეს საჭირო? იმიტომ, რომ მობილური ბრაუზერები ხშირად არ ასახავენ სწორად თავიანთი viewport-ის სიგანეს.

ეს მეტა თეგი არსებობს იმიტომ, რომ როცა სმარტფონები პირველად გამოჩნდა, ვებსაიტების უმეტესობა მობილურზე ოპტიმიზირებული არ იყო.
ამიტომ, მობილური ბრაუზერები აყენებდნენ viewport-ის სიგანეს 980 პიქსელზე, ამ სიგანით რენდერდებოდა (გამოისახებოდა) გვერდი და შედეგი ნაჩვენები იყო,
როგორც desktop განლაგების დაპატარავებული ვერსია. მომხმარებლებს შეეძლოთ ხედის გადიდება და გვერდზე გადაადგილება, რომ დაენახათ საინტერესო ნაწილები,
მაგრამ ვიზუალურად ეს ცუდად გამოიყურებოდა და არასასიამოვნო პროცესი იყო.

როდესაც აწესებთ `width=device-width`, ამით ცვლით მობილური მოწყობილობის ნაგულისხმევ მნიშვნელობას, მაგალითად iPhone-ს აქვს `width=980px`
მოწყობილობის ფაქტობრივი სიგანე. მის გარეშე, თქვენი რესპონსიული დიზაინის breakpoint და media query შესაძლოა მობილურ ბრაუზერებზე არასწორად მუშაობდეს.

ამიტომ ყოველთვის უნდა ჩართოთ viewport მეტა თეგი დოკუმენტის `head` ნაწილში.

## შეჯამება

ამ სტატიაში განვიხილეთ რესპონსიული ვებ დიზაინის (RWD) მნიშვნილობა, ტექნიკები და თანამედროვე მიდგომები.

## გამოყენებული ლიტერატურა

- [Responsive web design](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/CSS_layout/Responsive_Design)
